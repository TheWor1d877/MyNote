## 封装
隐藏实现细节，实现模块化
- 访问权限，属性与方法

## 继承
无需修改原有类的情况下实现功能的扩展
权限继承： 父类的属性与方法在子类中的最高权限

## 多态
多态：
- 静态多态
编译完成锁死调用目标，0运行开销

- 动态多态
根据传参的不同找到相关的运行代码，是运行期的多态
有运行开销

不能运算符重载
```cpp
struct Base {
	virtual Base operator + (const Base& rhs) const;
}

struct Der : Base {
	Base operator + (const Base& rhs) override const
} // 只能这么写

// 实际调用的是Base的+方法
Base& b1 = new(Der);
```

如果需要重载可以使用CRTP模式，在编译期间就绑定
```cpp
template <typename Derived>
struct Base {
    Derived operator + (const Derived& rhs) const {
        return static_cast<const Derived*>(this)->addImpl(rhs);
    }
}// 直接调用子类的实际实现
```

