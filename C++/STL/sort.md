## std::sort()的实现
1. **自适应混合排序算法**
2. **平均时间复杂度**：O(n log n)
3. **不稳定排序**（相等元素的顺序可能改变）
#### 为什么这样设计？

| 情况        | 使用的算法 | 原因                          |
| --------- | ----- | --------------------------- |
| **大规模数据** | 快速排序  | 平均 O(n log n)，常数因子小，实际速度快   |
| **递归过深**  | 堆排序   | 防止快速排序退化为 O(n²)，保证最坏情况性能    |
| **小规模数据** | 插入排序  | 当 n ≤ 16 时，插入排序的实际开销更小，缓存友好 |

- 快速排序**平均性能最好**（常数因子小）
- 堆排序**保证最坏情况**（防退化）
- 插入排序**小数据最快**（缓存友好）

#### 为什么大范围用快排？
快排： 时间复杂度O(n log n),常数因子小
不需要额外空间

#### 为什么递归过深切堆排？
快速排序最坏情况（如已排序数组）会退化为 O(n²)。
当递归深度达到 2×log₂n 时，说明分区不均衡，可能遇到最坏情况
堆排序虽然常数因子大，但保证 O(n log n)，防止程序卡死。

#### 为什么小区间用插排？
1. **消除递归开销**：快排递归的函数调用成本 > 排序成本
2. **缓存局部性**：插入排序顺序访问，CPU缓存命中率高
3. **实际更快**：当 n≤16 时，O(n²) 的插入排序比 O(n log n) 的快排实际更快”