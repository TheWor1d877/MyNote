STL的核心是六大组件协同工作：
- **容器 (Containers)**： 管理数据的各种数据结构，如`vector`、`list`。
- **算法 (Algorithms)**： 用于处理容器中数据的函数模板，如`sort()`、`find()`
- **迭代器 (Iterators)**： 提供访问容器元素的方法，是连接容器和算法的桥梁
- **函数对象 (Functors)**： 行为类似函数的对象
- **适配器 (Adapters)**： 修改容器或函数对象的接口，如`stack`、`queue`
- **分配器 (Allocators)**： 管理容器的内存分配
## 容器

| 容器分类 | 容器名称 | 底层数据结构 | 关键特性与实现细节 |
| :--- | :--- | :--- | :--- |
| **序列容器** | `vector` | **动态数组** | 三指针管理：`start`, `finish`, `end_of_storage`。扩容时通常翻倍，原迭代器全部失效。 |
| | `deque` | **分段连续数组** | “中控器”(`map`) + 固定大小缓冲区。迭代器含四个指针，模拟连续。 |
| | `list` | **双向循环链表** | 通常带“哨兵节点”，插入/删除仅使被操作元素迭代器失效。 |
| | `forward_list` | **单向链表** | C++11引入，为节省内存，无`size()`方法。 |
| | `array` | **静态数组** | C++11引入，包装固定大小数组，支持STL接口。 |
| **关联容器** | `set`/`map` | **红黑树** | 自动排序，键值唯一(`set`值即键)。增删查O(log n)。 |
| | `multiset`/`multimap` | **红黑树** | 允许重复键值。 |
| **无序容器** | `unordered_*` | **哈希桶** | 数组+链表(或红黑树)，`rehash`触发时迭代器失效。 |
| **适配器** | `stack`/`queue` | 默认基于`deque` | 封闭了序列容器的部分接口，符合特定数据结构语义。 |
| | `priority_queue` | **`vector` + 堆算法** | 底层结构是二叉堆，父节点值总大于/小于子节点。 |

#### vector (向量)
**动态数组**。维护三个关键指针：指向数据起始、尾元素的下一个位置、分配内存的末尾- 支持**随机访问**（O(1)）。
    
- 尾部插入删除高效（均摊O(1)）；在中间或头部插入删除需要移动元素（O(n)）。
- 内存连续，缓存友好。
- 容量不足时，会按一定策略（如翻倍）重新分配内存、复制元素，导致**迭代器失效**

#### deque (双端队列)
- **底层**：**分段连续存储的数组**。由一段段固定大小的数组（缓冲区）组成，通过一个“**中控器**”（指针数组或vector）来管理这些缓冲区
**特性**：
- 支持**随机访问**，但效率略低于`vector`。
- **首尾插入删除**都非常高效（O(1)）。
- 内存非完全连续，但迭代器模拟了连续性
![[Attachments/Pasted image 20251227101045.png]]
#### list (列表)
- **底层**：**双向循环链表**。通常包含一个不存储数据的“哨兵节点”以简化边界处理
- **特性**：
    - 在任何位置插入删除都是O(1)，只需修改指针
    - **不支持随机访问**（访问需O(n)）。 
    - 插入删除操作**不会使其他迭代器失效**。


## 迭代器失效
- **vector**： 插入/删除点及之后的迭代器、引用可能失效（尤其是引起扩容时，全部失效）。

- **deque**： 在首尾插入，迭代器通常不会失效；在中间插入，所有迭代器可能失效。删除操作通常会使指向删除点的迭代器失效。

- **list/map/set**： 插入不会使任何迭代器失效；删除仅使指向被删元素的迭代器失效。

- **建议**： 修改容器后，**不要保留旧的迭代器**，重新获取（如`it = vec.erase(it)`）。


## 空间配置器 (Allocator)
负责内存的分配与回收，默认实现是`std::allocator`。SGI STL提供了更复杂的**二级配置器**以优化小内存管理。
*   **一级配置器**：直接包装`malloc`和`free`，处理大块内存。
*   **二级配置器**：核心是**内存池**和**自由链表**。
    1.  维护一个自由链表数组（如16个），分别管理8、16、...、128字节的小块内存。
    2.  当申请小内存时，从对应链表取一块；归还时，插回链表。
    3.  链表为空时，从内存池中批量申请（如20块），这减少了系统调用次数和内存碎片。

## 算法与函数对象
*   **算法**： 如`sort`, `find`，是**函数模板**，通过迭代器操作容器，与容器实现**松耦合**。`sort`要求随机访问迭代器，故`list`有自定义的`sort`成员函数。
*   **函数对象**： 重载了`operator()`的类对象，行为像函数，可内联，效率可能高于函数指针。例如`greater<int>()`用于从大到小排序。
*   **适配器**：
    *   **容器适配器**：如`stack`，修改了底层容器（默认`deque`）的接口。
    *   **迭代器适配器**：如`back_insert_iterator`，将赋值操作转换为`push_back`。
    *   **函数适配器**：如`bind`, `not1`，用于组合或修改函数对象。

