**时间轮（Time Wheel）是高效管理大量定时任务的算法**，本质是 **“用哈希桶+轮转指针” 替代传统的优先队列（堆）**。
```
      时间轮（8个槽，每槽1秒）
     ┌─────┬─────┬─────┬─────┬─────┐
     │槽0  │槽1  │槽2  │槽3  │ ... │
     │(0s) │(1s) │(2s) │(3s) │     │
     ├─────┼─────┼─────┼─────┼─────┤
指针→│     │     │任务A│     │     │
     │     │     │任务B│     │     │
     └─────┴─────┴─────┴─────┴─────┘
         ↑    每1秒指针前进一格
     当前时间
```
## 为什么需要时间轮

| 方案       | 插入复杂度    | 触发复杂度    | 问题            |
| -------- | -------- | -------- | ------------- |
| **有序链表** | O(n)     | O(1)     | 插入慢           |
| **最小堆**  | O(log n) | O(log n) | 触发时调整堆        |
| **时间轮**  | **O(1)** | **O(1)** | **海量定时器场景最优** |
## 实际应用案例
- Linux内核定时器
```c
// 内核的5个时间轮（粒度：1, 8, 64, 512, 4096 jiffies）
struct tvec_base {
    struct tvec_root tv1;   // 0-255 (256槽)
    struct tvec tv2;        // 256-16383 (64槽)
    struct tvec tv3;        // 16384-1048575 (64槽)
    struct tvec tv4;        // 1048576-67108863 (64槽)
    struct tvec tv5;        // 67108864-4294967295 (64槽)
};
```

3. Kafka 延迟操作
```c
// Kafka 延迟请求管理
class DelayedOperationPurgatory {
    private TimingWheel delayQueue;  // 时间轮管理延迟请求
    
    // 延迟生产请求（等待副本确认）
    def tryCompleteElseWatch(delayedProduce: DelayedProduce) {
        delayQueue.add(delayedProduce)
    }
}
```

“时间轮是用环形数组+哈希思想管理定时器的算法。任务根据到期时间散列到不同槽中，指针每 tick 一格就批量执行当前槽的所有任务，实现 O(1) 的插入和触发复杂度。层级时间轮通过多级进位支持任意长延时。它比传统定时器堆性能高一个数量级，是高性能网络框架（如Netty、Kafka）的核心组件。”