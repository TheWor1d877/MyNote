B+Tree 是一种多路平衡搜索树，专为磁盘/数据库优化设计。
“所有数据都在叶子节点，叶子节点用链表串联，非叶子节点只存索引（不存数据）”

```
        [非叶子节点：索引层]
        ┌─────────────┐
        │ P1 │ 7 │ P2 │
        └─────────────┘
          /         \
         /           \
[叶子节点：数据层]   [叶子节点：数据层]
┌─────────────────┐  ┌─────────────────┐
│ 1 │ 3 │ 5 │ →   │  │ 7 │ 9 │ 11 │ →  │
└─────────────────┘  └─────────────────┘
        ↓                   ↓
    数据记录            数据记录
```




## 为什么数据库用 B+Tree

- 1. 更适合磁盘（减少 I/O）
- **节点大小 = 磁盘页大小**（如 4KB/16KB）一次磁盘 I/O 读一个节点（包含很多键）
- **树很矮**：3-4 层就能存 **千万/亿级** 数据


### **2. 范围查询极快**

- B+Tree：找到 20 的叶子节点，然后**顺着链表向后扫**
- B-Tree：需要不断回溯到父节点，再找下一个

## B+Tree vs 哈希索引

| 查询类型 | **B+Tree** | **哈希索引** |
| :--- | :--- | :--- |
| **等值查询** | O(log n) | **O(1)** |
| **范围查询** | **O(log n)**（优秀） | ❌ 不支持 |
| **排序/分组** | **天然有序** | ❌ 不支持 |
| **磁盘友好** | **优秀**（顺序访问） | 差（随机访问） |

## 面试回答模板
“B+Tree是一种多路平衡树，**数据只存在于叶子节点且用链表串联**，非叶子节点仅存索引。它通过**树矮（减少I/O）**、**节点大小对齐磁盘页**、**叶子链表支持高效范围查询**，成为数据库索引的事实标准。比如MySQL的InnoDB就使用B+Tree实现主键和二级索引。”

**记住三个数**：
1. **3-4层**：B+Tree的典型高度
2. **千万/亿级**：这个高度能存储的数据量
3. **1次I/O**：每层可能只需一次磁盘读取