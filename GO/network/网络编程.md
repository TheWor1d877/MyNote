Go 的网络库分层清晰
```text
应用层： net/http（HTTP/1.1, HTTP/2）
         ↓
传输层： net（TCP/UDP/Unix Socket）
         ↓
系统调用： syscall（Linux: socket, bind, listen, accept, read, write）
```
Go的网络模型是Preactor风格的(异步)
用户态下面阻塞，runtime中非阻塞
本质跟Nginx一样
go的io表面上面是Preactor模型，但是底层还是Reactor那一套
这样的优点： 代码写起来像同步，性能接近异步

# TCP
| C/C++ 常见操作 | Go 等价写法 |
|----------------|-------------|
| `socket(AF_INET, SOCK_STREAM, 0)` | `net.Listen("tcp", ":port")` |
| `bind()` + `listen()` | 内部自动完成 |
| `accept()` | `listener.Accept()` → 返回 `net.Conn` |
| `read()` / `write()` | `conn.Read()` / `conn.Write()` |
| `setsockopt(SO_KEEPALIVE)` | `(*TCPConn).SetKeepAlive(true)` |

## 获取底层TCP控制权
```go
func handleConn(rawConn net.Conn) {
	tcpConn := rawConn.(*net.TCPConn)
	// 开启Tcp keepalive机制
	tcpConn.SetKeepAlive(true)
	// 禁用Nagle算法，减少小包延迟
	tcpConn.SetNoDelay(true)
	// 优雅关闭，0是立即关闭，-1系统默认等待，大于0等待时间
	/*
		0: 发送RST重置连接
		N>0： 尝试发送缓冲区剩余数据，最多Ns 用Close()进行四次挥手
		如果Ns没发送完成，直接RST(TCP保证的是已发送数据的可靠传输)
	*/
	tcpConn.SetLinger()
	// 设置读写内核缓冲区，默认是64kb大小
	tcpConn.SetReadBuffer()
	tcpConn.SetWriteBuffer()
	// 设置超时时间，超过这个时间READ/WRITE没有相应就返回错误，而不是关闭连接
	// 作用是防止单次read/write阻塞
	tcpConn.SetDeadline()
	tcpConn.SetReadDeadline()
	tcpConn.SetWriteDeadline()
}
```

## TCP客户端
#### 具有重新连接与上下文
```go
func SetWithRetry(ctx context.Context, addr string) (net.Conn, error) {
	for {
		select {
		case <-ctx.Done():
			return nil, ctx.Err()
		default:
		}

		conn, err := net.DialTimeout("tcp", addr, time.Second)
		if err != nil {
			log.Println("Failed to connect to", addr, " error:", err.Error())
			time.Sleep(500 * time.Millisecond)
		} else {
			tcpConn := conn.(*net.TCPConn)
			err := tcpConn.SetKeepAlive(true)
			if err != nil {
				return nil, err
			}
			err = tcpConn.SetNoDelay(true)
			if err != nil {
				return nil, err
			}
			return tcpConn, nil
		}

	}
}
```
