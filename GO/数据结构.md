## slice
```go
// runtime/slice.go  简化版
type slice struct {
    array unsafe.Pointer // 指向底层数组
    len   int            // 当前元素个数
    cap   int            // 底层数组最大容量
}
```
#### 扩容规则
旧容量 < 256 → 双倍
旧容量 ≥ 256 → 1.25 倍 + 192 的“平滑”策略，减少大 slice 的内存陡增 
拷贝是浅拷贝

## struct 内存对齐
每个字段的起始地址必须是它自身对齐值的整数倍，结构体总大小必须是所有字段最大对齐值的整数倍
```go
type Bad struct {
    a bool   // 1
    b int64  // 8
    c bool   // 1
}
type Good struct {
    b int64  // 8
    a bool   // 1
    c bool   // 1
}
fmt.Println(unsafe.Sizeof(Bad{}))  // 24
fmt.Println(unsafe.Sizeof(Good{})) // 16
```
#### 空结构体struct{}
大小为 0，但放在最后一个字段时会被填充到“前一个字段大小”的倍数，这是为了指针地址安全，防止越界访问 
```go
type T struct {
    c int32
    _ struct{}
}
fmt.Println(unsafe.Sizeof(T{})) // 8  不是 4
```

## map
头部 hmap（运行时叫 runtime.hmap）
```go
复制
type hmap struct {
    count      int        // 当前存了多少 key
    flags      uint8      // 标志位，比如是否正在扩容
    B          uint8      // 桶的个数 = 2^B
    noverflow  uint16     // 溢出桶大概数量
    hash0      uint32     // hash 随机种子，防哈希碰撞攻击
    buckets    unsafe.Pointer  // 指向 []bmap，真正放数据的地方
    oldbuckets unsafe.Pointer  // 扩容时指向老的 []bmap
    nevacuate  uintptr         // 搬迁进度，小于它的桶已搬完
    extra      *mapextra        // 溢出桶的指针池，减少 GC 扫描
}
```

大小固定 48 B（64 位），你 `make(map[k]v)` 完就得到这么一个头。
桶 bmap（源码里叫 runtime.bmap，但编译器偷偷给后面续内存）
```go
type bmap struct {
    tophash [8]uint8   // 8 个槽位的高 8 位 hash，0 表示空
    // 编译器在后面紧跟着分配
    keys   [8]keytype   // 8 个 key 连续放
    elems  [8]elemtype  // 8 个 value 连续放
    overflow *bmap      // 拉链，指向下一个溢出桶
}
```

查找数据的时候现找到相关的桶然后找到相关的数据