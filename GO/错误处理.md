Errors should be handled, not hidden
错误是值”（Errors are values）。

- 要点 1：基础 error 接口
- 要点 2：自定义错误类型（带上下文）
- 要点 3：Go 1.13+ 错误增强（errors 包）
1. fmt.Errorf("%w",err)
```go
if _,err := os.Open("file.txt"); err != nil{
	return fmt.Errorf("failed to open config",err)
}
```
2. errors.Is(err,target)
```go
if errors.Is(err,os.ErrNotEixst){
	//即使包装多层也能识别
}
```
3. errors.As(err,&target)提取特定类型的错误
```go
var pathErr *os.PathError
if errors.As(err,&pathErr){
	fmt.Println("Broken file:",pathErr.Path)
}
```
- 要点 4：panic / recover —— 仅用于“不可能发生”的严重错误
panic不能用于处理常规错误，panic会立即停止当前的goroutine
recover只能在defer中捕获panic
recover的作用就是不让panic真正输出而是在返回之前如果有panic就在defer 中做处理


最佳实践：
库代码：**永远不要 panic**（除非文档明确说明）
主程序：可用 panic 表示致命错误（如配置解析失败）
HTTP handler：框架通常自动 recover 防止服务崩溃

## 错误处理实践原则
1. 简单错误： 使用errors.New或者fmt.Errorf
2. 需要堆栈信息，是否包含某类错误等等：  使用errors包
3. HTTP/gRPC:统一错误吗 + 日志记录，避免暴露内部细节 
4. 不能忽略错误
