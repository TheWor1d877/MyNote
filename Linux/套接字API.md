socket() – 创建端点，创建一个通信端点（socket），返回文件描述符。
bind() – 绑定地址，将 socket 绑定到本地 IP 地址和端口
listen() – 开启监听 bh 将 socket 设置为被动监听模式，并定义连接队列的最大长度。（将使用socket创建的主动套接字转换成监听套接字）
accept() – 接受连接，监听 socket 只负责接受连接，新返回的已连接描述符用于数据收发


## IO多路复用
一种机制，用于监控多个文件描述符的状态，使用 select/poll/epoll 同时监控多个 socket（包括监听 socket 和已连接的 socket）。当 epoll 通知“监听 socket 可读”时，通常表示有新连接到达，此时需要调用 accept() 去接受该连接。

#### select，poll，epoll的区别
- select
select使用fd_set位图作为数据结构，最大连接数量是1024,工作效率是O(N)的，cpu一直在轮询，然后每次调用都需要全量拷贝fd_set进出内核
缺点：
最大 fd 数限制（编译内核可改，但麻烦）
每次需重置 fd_set（因为内核会修改它）
每次调用都需将整个 fd_set 从用户态拷到内核态

- poll
poll的底层是pollfd链表，最大连接数理论上无上限，工作效率是O(N)的，内存拷贝同select
缺点： 
仍需要线性扫描所有 fd（即使只有一个就绪）
每次调用仍需拷贝整个数组到内核

- epoll
epoll 是使用红黑树加上就绪链表，理论上最大连接数无上限，工作效率O(1),只返回就绪的fd，内存上使用共享内存，避免每次拷贝，只需要一次注册
红黑树存储所有注册的fd，共享链表存储就绪的fd
- epoll_create()：创建 epoll 实例
- epoll_ctl()：注册/修改/删除 fd（一次注册，永久有效）
- epoll_wait()：等待就绪事件


回答方向： 数据结构，最大连接数，工作效率，操作内存的方式

##### 附加：
- 水平触发LT 与 边缘触发ET
LT :  fd就绪的时候只要这个fd没有处理完成，那么epoll_wait就返回
ET： fd状态变化只通知一次，必须一次处理完成所有的长期服的数据

只有epoll支持ET边缘触发 => ET 迫使你一次处理完所有数据（读到 EAGAIN），这往往更符合高性能服务器的设计,减少系统调用次数（批量处理）
更好的缓存局部性（连续处理数据),避免数据在缓冲区中“粘滞”
   

- epoll 惊群问题：多个进程/线程等待同一 fd，事件到来时全部被唤醒（Linux 4.5+ 已优化）
  
  