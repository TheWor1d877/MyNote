## Reactor 
#### introduction
数据流动路线
```text
网络数据 → 网卡 → [内核缓冲区] → read()系统调用 → [应用程序缓冲区] → 应用程序使用
```
应用程序直接将数据从内核缓冲区read()到应用程序缓冲区
每一次read都有上下文切换的开销和内存复制的开销
编程复杂度相对较低，流程直观，但需要处理部分并发控制。
#### IO操作与分工
同步非阻塞，Reactor线程用于监听事件就绪，其他应用线程用于执行IO操作与业务逻辑
## Proactor
#### introduction
数据流通路线
```text
网络数据 → 网卡 → [内核缓冲区] → 内核直接复制 → [应用程序缓冲区] → 回调通知应用程序
```
操作系统内核将数据从内核缓冲区直接搬运到相应的用户态内存地址下面
内核可以批量复制，减少内存开销
编程复杂度相对较高，回调链可能复杂，但业务逻辑线程更纯净
#### IO操作与分工
异步完成，Proactor用于监听事件然后执行IO操作，其他线程只用于处理相关的业务逻辑

#### Linux为什么不使用Proactor?
“Linux原生异步I/O（aio）对网络socket支持一直不够成熟，而epoll这种‘通知就绪’的模型已经足够高性能，生态完善。所以像Nginx、Redis这些主流框架都基于Reactor。
不过现在很多框架（如Boost.Asio）会在底层用Reactor模拟Proactor的接口，让开发者享受异步编程的便利。”

## 同步与异步，阻塞与非阻塞
#### 同步与异步
消息通知机制的不同
同步是调用者主动等待结果，可能需要等待其他线程完成任务之后才能继续往下执行代码
异步是调用者发起请求后继续执行代码，经过回调函数获得结果。
###### CPU的视角
同步： A执行代码，发生阻塞，CPU切换到B，执行B的代码，然后完成之后返回到A
执行流是线性的，但在调用点会卡住
异步： 执行一些代码...，发起async_request_to_B(),等待B完成之后，被动接收通知

#### 阻塞与非阻塞
等待状态的不同
阻塞是调用之后线程被挂起，等待结果完成之后再返回，如read写入内存需要阻塞等待
非阻塞就是调用之后立即返回，不管操作是否完成，检查是否可读可写是非阻塞的
