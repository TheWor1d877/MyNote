一种机制，用于监控多个文件描述符的状态，使用 select/poll/epoll 同时监控多个 socket（包括监听 socket 和已连接的 socket）。当 epoll 通知“监听 socket 可读”时，通常表示有新连接到达，此时需要调用 accept() 去接受该连接。

#### select，poll，epoll的区别
- select
select使用fd_set位图作为数据结构，最大连接数量是1024,工作效率是O(N)的，cpu一直在轮询，然后每次调用都需要全量拷贝fd_set进出内核
缺点：
最大 fd 数限制（编译内核可改，但麻烦）
每次需重置 fd_set（因为内核会修改它）
每次调用都需将整个 fd_set 从用户态拷到内核态

- poll
poll的底层是pollfd链表，最大连接数理论上无上限，工作效率是O(N)的，内存拷贝同select
缺点： 
仍需要线性扫描所有 fd（即使只有一个就绪）
每次调用仍需拷贝整个数组到内核

- epoll
epoll 是使用红黑树加上就绪链表，理论上最大连接数无上限，工作效率O(1),只返回就绪的fd，内存上使用共享内存，避免每次拷贝，只需要一次注册
红黑树存储所有注册的fd，共享链表存储就绪的fd
- epoll_create()：创建 epoll 实例
- epoll_ctl()：注册/修改/删除 fd（一次注册，永久有效）
- epoll_wait()：等待就绪事件


回答方向： 数据结构，最大连接数，工作效率，操作内存的方式

##### 附加：
- 水平触发LT 与 边缘触发ET
LT :  fd就绪的时候只要这个fd没有处理完成，那么epoll_wait就返回
ET： fd状态变化只通知一次，必须一次处理完成所有的长期服的数据

只有epoll支持ET边缘触发 => ET 迫使你一次处理完所有数据（读到 EAGAIN），这往往更符合高性能服务器的设计,减少系统调用次数（批量处理）
更好的缓存局部性（连续处理数据),避免数据在缓冲区中“粘滞”
   

- epoll 惊群问题：多个进程/线程等待同一 fd，事件到来时全部被唤醒（Linux 4.5+ 已优化）
## 缓冲区
发送缓冲区
接受缓冲区
read缓冲区(代码中的buffer)
应用层

## epoll
场景：对方发送了 "HelloWorld"（10字节）
你的缓冲区大小：5字节

#### LT模式：
1. 只要socket的接收缓冲区还有数据可读，或者发送缓冲区还有空间可写，epoll_wait就会持续通知你。
2. 在这种模式下，我可以从容不迫地处理数据——每次通知时，我可以选择读取部分数据，剩下的下次再处理；发送时如果缓冲区满了，epoll会不断提醒我可写状态，让我能分批发送。
3. 这种模式编程简单，不容易丢失数据，特别适合刚开始接触epoll或者对性能要求不是极致的场景
```text
第一次epoll_wait返回："有数据来了！"
你：read() 读5字节 → "Hello"

第二次epoll_wait（很快又返回）："还有数据！"
你：read() 读5字节 → "World"

第三次epoll_wait：不返回（数据读完了）
```
#### ET模式：
1. 它只在socket状态发生变化时通知一次：从不可读到可读，或者从不可写到可写。
2. 这就要求我必须一次性处理完所有数据——读取时要循环读取直到EAGAIN错误，确保清空接收缓冲区；发送时如果没发完，需要自己缓存剩余数据并重新监听可写事件。
3. ET模式减少了epoll_wait的系统调用次数，性能更高，但编程复杂度也更高，必须配合非阻塞socket使用，且要小心处理数据边界和状态管理。
注意：ET模式下，超过内核缓冲区的数据会永远丢失！
最佳实践 ： ET读 + LT写（混合模式）
```text
第一次epoll_wait返回："有数据来了！"
你：read() 读5字节 → "Hello"
    继续read() → EAGAIN（缓冲区空了）
    停止读取

第二次对方发送新数据前：
epoll_wait不会返回！因为数据状态没变化（都是"可读"）
你收不到 "World"！直到对方再发新数据
```

#### 补充
###### 1. ET多一次read开销
隐藏开销：最后一次 read 必然失败（EAGAIN）
这是 ET 模式的硬性要求：你必须 read 到 EAGAIN 才知道“读完了”。
而 LT 模式不需要这次失败的 read！
故：小包、短连接（如 HTTP）→ 用 LT
  大流量、长连接（如视频流）→ 用 ET + 大 BUFFER
###### 2. IO均匀
ET 模式在处理多个就绪 fd 时，会“集中火力”逐个 while-read 到空，导致 CPU 忙闲不均——某些时刻狂读一个 fd，其他就绪 fd 被延迟；而 LT 每次只读一点就交还控制权，让 epoll 均匀调度所有 fd，IO 更平滑、响应更均衡。

###### 3.ET与LT选择
监听描述符上ET就行了
小文件使用LT好，减少read次数
大文件，使用ET就要配上大BUFFER保证数据安全同时减少系统调用，如果保障数据绝对安全还是使用LT吧
